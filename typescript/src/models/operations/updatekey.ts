/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as z from "zod";

/**
 * Fast ratelimiting doesn't add latency, while consistent ratelimiting is more accurate.
 *
 * @see {@link https://unkey.dev/docs/features/ratelimiting} - Learn more
 */
export enum UpdateKeyType {
    Fast = "fast",
    Consistent = "consistent",
}

/**
 * Unkey comes with per-key ratelimiting out of the box. Set `null` to disable.
 */
export type UpdateKeyRatelimit = {
    /**
     * Fast ratelimiting doesn't add latency, while consistent ratelimiting is more accurate.
     */
    type: UpdateKeyType;
    /**
     * The total amount of burstable requests.
     */
    limit: number;
    /**
     * How many tokens to refill during each refillInterval.
     */
    refillRate: number;
    /**
     * Determines the speed at which tokens are refilled, in milliseconds.
     */
    refillInterval: number;
};

/**
 * Unkey will automatically refill verifications at the set interval. If null is used the refill functionality will be removed from the key.
 */
export enum UpdateKeyInterval {
    Daily = "daily",
    Monthly = "monthly",
}

/**
 * Unkey enables you to refill verifications for each key at regular intervals.
 */
export type UpdateKeyRefill = {
    /**
     * Unkey will automatically refill verifications at the set interval. If null is used the refill functionality will be removed from the key.
     */
    interval: UpdateKeyInterval;
    /**
     * The amount of verifications to refill for each occurrence is determined individually for each key.
     */
    amount: number;
};

export type UpdateKeyRequestBody = {
    /**
     * The id of the key you want to modify
     */
    keyId: string;
    /**
     * The name of the key
     */
    name?: string | null | undefined;
    /**
     * The id of the tenant associated with this key. Use whatever reference you have in your system to identify the tenant. When verifying the key, we will send this field back to you, so you know who is accessing your API.
     */
    ownerId?: string | null | undefined;
    /**
     * Any additional metadata you want to store with the key
     */
    meta?: Record<string, any> | null | undefined;
    /**
     * The unix timestamp in milliseconds when the key will expire. If this field is null or undefined, the key is not expiring.
     */
    expires?: number | null | undefined;
    /**
     * Unkey comes with per-key ratelimiting out of the box. Set `null` to disable.
     */
    ratelimit?: UpdateKeyRatelimit | null | undefined;
    /**
     * The number of requests that can be made with this key before it becomes invalid. Set `null` to disable.
     */
    remaining?: number | null | undefined;
    /**
     * Unkey enables you to refill verifications for each key at regular intervals.
     */
    refill?: UpdateKeyRefill | null | undefined;
    /**
     * Set if key is enabled or disabled. If disabled, the key cannot be used to verify.
     */
    enabled?: boolean | undefined;
};

/**
 * The key was successfully updated, it may take up to 30s for this to take effect in all regions
 */
export type UpdateKeyResponseBody = {};

/** @internal */
export const UpdateKeyType$ = z.nativeEnum(UpdateKeyType);

/** @internal */
export namespace UpdateKeyRatelimit$ {
    export type Inbound = {
        type: UpdateKeyType;
        limit: number;
        refillRate: number;
        refillInterval: number;
    };

    export const inboundSchema: z.ZodType<UpdateKeyRatelimit, z.ZodTypeDef, Inbound> = z
        .object({
            type: UpdateKeyType$,
            limit: z.number().int(),
            refillRate: z.number().int(),
            refillInterval: z.number().int(),
        })
        .transform((v) => {
            return {
                type: v.type,
                limit: v.limit,
                refillRate: v.refillRate,
                refillInterval: v.refillInterval,
            };
        });

    export type Outbound = {
        type: UpdateKeyType;
        limit: number;
        refillRate: number;
        refillInterval: number;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, UpdateKeyRatelimit> = z
        .object({
            type: UpdateKeyType$,
            limit: z.number().int(),
            refillRate: z.number().int(),
            refillInterval: z.number().int(),
        })
        .transform((v) => {
            return {
                type: v.type,
                limit: v.limit,
                refillRate: v.refillRate,
                refillInterval: v.refillInterval,
            };
        });
}

/** @internal */
export const UpdateKeyInterval$ = z.nativeEnum(UpdateKeyInterval);

/** @internal */
export namespace UpdateKeyRefill$ {
    export type Inbound = {
        interval: UpdateKeyInterval;
        amount: number;
    };

    export const inboundSchema: z.ZodType<UpdateKeyRefill, z.ZodTypeDef, Inbound> = z
        .object({
            interval: UpdateKeyInterval$,
            amount: z.number().int(),
        })
        .transform((v) => {
            return {
                interval: v.interval,
                amount: v.amount,
            };
        });

    export type Outbound = {
        interval: UpdateKeyInterval;
        amount: number;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, UpdateKeyRefill> = z
        .object({
            interval: UpdateKeyInterval$,
            amount: z.number().int(),
        })
        .transform((v) => {
            return {
                interval: v.interval,
                amount: v.amount,
            };
        });
}

/** @internal */
export namespace UpdateKeyRequestBody$ {
    export type Inbound = {
        keyId: string;
        name?: string | null | undefined;
        ownerId?: string | null | undefined;
        meta?: Record<string, any> | null | undefined;
        expires?: number | null | undefined;
        ratelimit?: UpdateKeyRatelimit$.Inbound | null | undefined;
        remaining?: number | null | undefined;
        refill?: UpdateKeyRefill$.Inbound | null | undefined;
        enabled?: boolean | undefined;
    };

    export const inboundSchema: z.ZodType<UpdateKeyRequestBody, z.ZodTypeDef, Inbound> = z
        .object({
            keyId: z.string(),
            name: z.nullable(z.string()).optional(),
            ownerId: z.nullable(z.string()).optional(),
            meta: z.nullable(z.record(z.any())).optional(),
            expires: z.nullable(z.number()).optional(),
            ratelimit: z.nullable(z.lazy(() => UpdateKeyRatelimit$.inboundSchema)).optional(),
            remaining: z.nullable(z.number()).optional(),
            refill: z.nullable(z.lazy(() => UpdateKeyRefill$.inboundSchema)).optional(),
            enabled: z.boolean().optional(),
        })
        .transform((v) => {
            return {
                keyId: v.keyId,
                ...(v.name === undefined ? null : { name: v.name }),
                ...(v.ownerId === undefined ? null : { ownerId: v.ownerId }),
                ...(v.meta === undefined ? null : { meta: v.meta }),
                ...(v.expires === undefined ? null : { expires: v.expires }),
                ...(v.ratelimit === undefined ? null : { ratelimit: v.ratelimit }),
                ...(v.remaining === undefined ? null : { remaining: v.remaining }),
                ...(v.refill === undefined ? null : { refill: v.refill }),
                ...(v.enabled === undefined ? null : { enabled: v.enabled }),
            };
        });

    export type Outbound = {
        keyId: string;
        name?: string | null | undefined;
        ownerId?: string | null | undefined;
        meta?: Record<string, any> | null | undefined;
        expires?: number | null | undefined;
        ratelimit?: UpdateKeyRatelimit$.Outbound | null | undefined;
        remaining?: number | null | undefined;
        refill?: UpdateKeyRefill$.Outbound | null | undefined;
        enabled?: boolean | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, UpdateKeyRequestBody> = z
        .object({
            keyId: z.string(),
            name: z.nullable(z.string()).optional(),
            ownerId: z.nullable(z.string()).optional(),
            meta: z.nullable(z.record(z.any())).optional(),
            expires: z.nullable(z.number()).optional(),
            ratelimit: z.nullable(z.lazy(() => UpdateKeyRatelimit$.outboundSchema)).optional(),
            remaining: z.nullable(z.number()).optional(),
            refill: z.nullable(z.lazy(() => UpdateKeyRefill$.outboundSchema)).optional(),
            enabled: z.boolean().optional(),
        })
        .transform((v) => {
            return {
                keyId: v.keyId,
                ...(v.name === undefined ? null : { name: v.name }),
                ...(v.ownerId === undefined ? null : { ownerId: v.ownerId }),
                ...(v.meta === undefined ? null : { meta: v.meta }),
                ...(v.expires === undefined ? null : { expires: v.expires }),
                ...(v.ratelimit === undefined ? null : { ratelimit: v.ratelimit }),
                ...(v.remaining === undefined ? null : { remaining: v.remaining }),
                ...(v.refill === undefined ? null : { refill: v.refill }),
                ...(v.enabled === undefined ? null : { enabled: v.enabled }),
            };
        });
}

/** @internal */
export namespace UpdateKeyResponseBody$ {
    export type Inbound = {};

    export const inboundSchema: z.ZodType<UpdateKeyResponseBody, z.ZodTypeDef, Inbound> = z.object(
        {}
    );

    export type Outbound = {};

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, UpdateKeyResponseBody> =
        z.object({});
}
